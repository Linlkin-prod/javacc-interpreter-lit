PARSER_BEGIN(Parser)

/** Simple brace matcher. */
public class Parser {
	public static void main (String args[]) {
		Parser parser;
		if (args.length == 0) {
			System.out.println("Entrée standard");
			parser = new Parser(System.in);
		} else if (args.length == 1) {
			System.out.println("Analyse du fichier : " + args[0] + " ... ");
			try {
				parser = new Parser(new java.io.FileInputStream(args[0]));
			} catch (java.io.FileNotFoundException e) {
				System.out.println("Le fichier : " + args[0] + " n'est pas trouvé");
				return;
			}
		} else {
			System.out.println("Erreur de lecture");
			return;
		}
		try {
			Program program = parser.Input();
			System.out.println("Analyse syntaxique OK");
			System.out.println("Exécution du programme...");
			program.execute();
			System.out.println("Programme exécuté avec succès");
		} catch (ParseException e) {
			System.out.println("L'analyse syntaxique révèle des erreurs");
		} catch (Exception e) {
			System.out.println("Erreur lors de l'exécution : " + e.getMessage());
			e.printStackTrace();
		}
	}
}

PARSER_END(Parser)

SKIP : {
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}

SPECIAL_TOKEN : {
    <SingleLineComment : "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN : {
      <FUNC            : "func">
	| <PROC			   : "proc">
	| <MAIN            : "main">
	| <RETURN         : "return">
	| <IF             : "if">
	| <ELSE           : "else">
	| <WHILE          : "while">
	| <BEGIN           : "{">
	| <END             : "}">
	| <PARAM_SEPARATOR : ",">
	| <SEMICOLON      : ";">
	| <INT_TYPE        : "int">
	| <BOOL_TYPE       : "bool">
	| <FLOAT_TYPE      : "float">
	| <STR_TYPE        : "str">
	| <INSTRUCTION     : "Instruction"> // temporaire
	| <ASSIGNATION     : "=">
	| <PLUS            : "+">
	| <MINUS           : "-">
	| <MULTIPLY        : "*">
	| <DIVIDE          : "/">
	| <LPAREN          : "(">
	| <RPAREN          : ")">
	| <AND: "&">
	| <OR: "||">
	| <NOT: "!">
	| <SMALLER_EQUAL: "=<">
	| <BIGGER_EQUAL: "=>">
	| <EQUAL: "==">
	| <SMALLER: "<">
	| <BIGGER: ">">
	| <BOOL: "true" | "false">
	| <STRING_LITERAL: "\"" (~["\"", "\n", "\r"])* "\"">
	| <INTEGER_LITERAL : "0" | ["1"-"9"] (["0"-"9"])* >
	| <FLOAT :
        (["0"-"9"])+ "." (["0"-"9"])* (<EXP>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXP>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXP> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXP>)? ["f","F","d","D"]
    >
	| <#EXP : ["e","E"] (["+","-"])? (["0"-"9"])+ >
	| <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* >
	| <#LETTER :
        [
          "a"-"z","A"-"Z"
        ]
    >
	| <#DIGIT :
        [
          "0"-"9"
        ]
    >
}

/** Root production. */
Program Input() :
{ Program program; }
{
	program = Program() <EOF>
	{ return program; }
}

FunctionDef Function() :
{ String returnType; String name; java.util.List<Parameter> params; java.util.List<Statement> statements; }
{
	<FUNC> returnType = Type() name = <IDENTIFIER>.image <LPAREN> params = ParamaterList() <RPAREN> <BEGIN> statements = BlocStatement() <END>
	{ return new FunctionDef(name, returnType, params, statements); }
}

void Procedure() :
{ String name; java.util.List<Parameter> params; java.util.List<Statement> statements; }
{
	<PROC> name = <IDENTIFIER>.image <LPAREN> params = ParamaterList() <RPAREN> <BEGIN> statements = BlocStatement() <END>
}

String Type() :
{ Token t; }
{
	( t = <INT_TYPE> | t = <BOOL_TYPE> | t = <FLOAT_TYPE> | t = <STR_TYPE> )
	{ return t.image; }
}

Statement Instruction() :
{ String id; Expression expr; Statement stmt; java.util.List args; }
{
	/*Toucher pas à ça pitié*/
	LOOKAHEAD(<IDENTIFIER> <ASSIGNATION>) id = <IDENTIFIER>.image <ASSIGNATION> expr = Expression() <SEMICOLON>
	{ return new Assignment(id, expr); }
	| id = <IDENTIFIER>.image <LPAREN> args = InputParametersList() <RPAREN> <SEMICOLON>
	{ return new ExpressionStatement(new FunctionCall(id, args)); }
	| stmt = ReturnStatement() 
	{ return stmt; }
	| stmt = IfStatement() 
	{ return stmt; }
	| stmt = WhileStatement()
	{ return stmt; }
}

java.util.List<Parameter> ParamaterList() :
{ java.util.List<Parameter> params = new java.util.ArrayList<Parameter>(); Parameter p; }
{
    ( p = Paramater() { params.add(p); } ( <PARAM_SEPARATOR> p = Paramater() { params.add(p); } )* )?
    { return params; }
}

Parameter Paramater() :
{ String type; String name; }
{
	type = Type() name = <IDENTIFIER>.image
	{ return new Parameter(type, name); }
}

java.util.List<Statement> BlocInstructions() :
{ java.util.List<Statement> stmts = new java.util.ArrayList<Statement>(); Statement s; }
{
	( s = Instruction() { stmts.add(s); } )* 
	{ return stmts; }
}

java.util.List<Statement> BlocInitialisation() :
{ java.util.List<Statement> stmts = new java.util.ArrayList<Statement>(); Statement s; }
{
	( s = Initialisation() { stmts.add(s); } )* 
	{ return stmts; }
}

Statement Initialisation() :
{ String type; String name; Expression expr = null; }
{
	type = Type() name = <IDENTIFIER>.image ( <ASSIGNATION> expr = Expression() )? <SEMICOLON>
	{ return new VariableDeclaration(type, name, expr); }
}

Statement ReturnStatement() :
{ Expression expr; }
{
	<RETURN> expr = Expression() <SEMICOLON>
	{ return new ReturnStatement(expr); }
}

java.util.List<Expression> InputParametersList() :
{ java.util.List<Expression> exprs = new java.util.ArrayList<Expression>(); Expression e; }
{
	( e = Expression() { exprs.add(e); } ( <PARAM_SEPARATOR> e = Expression() { exprs.add(e); } )* )? 
	{ return exprs; }
}

Expression FunctionCall() :
{ String name; java.util.List<Expression> args; }
{
	name = <IDENTIFIER>.image <LPAREN> args = InputParametersList() <RPAREN>
	{ return new FunctionCall(name, args); }
}


Statement IfStatement() :
{ Expression cond; java.util.List<Statement> thenBlock; java.util.List<Statement> elseBlock = null; }
{
	<IF> <LPAREN> cond = LogExpression() <RPAREN> <BEGIN> thenBlock = BlocStatement() <END> ( <ELSE> <BEGIN> elseBlock = BlocStatement() <END> )?
	{ return new IfStatement(cond, thenBlock, elseBlock); }
}

Statement WhileStatement() :
{ Expression cond; java.util.List<Statement> body; }
{
	<WHILE> <LPAREN> cond = LogExpression() <RPAREN> <BEGIN> body = BlocStatement() <END>
	{ return new WhileStatement(cond, body); }
}

FunctionDef ProcFunc () :
{ FunctionDef f; }
{
	f = Function() { return f; }
	| Procedure() { return null; }
}

java.util.List<FunctionDef> FunctionProcedureBlock() :
{ java.util.List<FunctionDef> funcs = new java.util.ArrayList<FunctionDef>(); FunctionDef f; }
{
	( f = ProcFunc() { if (f != null) funcs.add(f); } )*
	{ return funcs; }
}

MainBlock mainFunction() :
{ java.util.List<Statement> statements; }
{
	<MAIN> <LPAREN> <RPAREN> <BEGIN> statements = BlocStatement() <END>
	{ return new MainBlock(statements); }
}

java.util.List<Statement> BlocStatement() :
{ java.util.List<Statement> stmts = new java.util.ArrayList<Statement>(); Statement s; }
{
	( s = Statement() { stmts.add(s); } )*
	{ return stmts; }
}

Statement Statement() :
{ Statement stmt; }
{
	stmt = Initialisation() 
	{ return stmt; }
	| stmt = Instruction()
	{ return stmt; }
}

Program Program() :
{ java.util.List<FunctionDef> functions; MainBlock main; }
{
	functions = FunctionProcedureBlock() main = mainFunction()
	{ return new Program(functions, main); }
}

/**
* Opération arithmétique
*/

/** Arithmetic expression production. */
Expression ArExpression() :
{ Expression term; Expression result; String op; }
{
	result = Term() ( (op = <PLUS>.image | op = <MINUS>.image) term = Term() { result = new BinaryOp(result, op, term); } )*
	{ return result; }
}

/** Term production (multiplication/division). */
Expression Term() :
{ Expression factor; Expression result; String op; }
{
	result = Factor() ( (op = <MULTIPLY>.image | op = <DIVIDE>.image) factor = Factor() { result = new BinaryOp(result, op, factor); } )*
	{ return result; }
}

/** Factor production (numbers and parenthesized expressions). */
Expression Factor() :
{ Token t; Expression expr; }
{
	( t = <INTEGER_LITERAL> { return new IntegerLiteral(Integer.parseInt(t.image)); }
	| t = <FLOAT> { return new FloatLiteral(Double.parseDouble(t.image)); }
	| t = <STRING_LITERAL> { String s = t.image; return new StringLiteral(s.substring(1, s.length()-1)); }
	| <LPAREN> expr = ArExpression() <RPAREN> { return expr; }
	| LOOKAHEAD(<IDENTIFIER> <LPAREN>) expr = FunctionCall() { return expr; }
	| t = <IDENTIFIER> { return new Variable(t.image); }
	)
}

/**
* Opération Logique
*/

/** Logical expression production */
Expression LogExpression() :
{ Expression term; Expression result; }
{
	result = LogTerm() ( <OR> term = LogTerm() { result = new BinaryOp(result, "||", term); } )*
	{ return result; }
}

/** Logical Term production */
Expression LogTerm() :
{ Expression element; Expression result; }
{
	result = LogElement() ( <AND> element = LogElement() { result = new BinaryOp(result, "&", element); } )*
	{ return result; }
}

/** Logical element production */
Expression LogElement() :
{ Expression value; }
{
	value = LogValue() { return value; }
	| <NOT> value = LogValue() { return new UnaryOp("!", value); }
}

/** Logical Value production */
Expression LogValue() :
{ Expression comp; Expression arith; Token t; }
{
	LOOKAHEAD(ArExpression() OpComp()) comp = Comp() { return comp; }
	| t = <BOOL> { return new BooleanLiteral(Boolean.parseBoolean(t.image)); }
	| <LPAREN> comp = LogExpression() <RPAREN> { return comp; }
	| LOOKAHEAD(<IDENTIFIER> <LPAREN>) arith = FunctionCall() { return arith; }
	| arith = ArExpression() { return arith; }
}

/** Comparaison production */
Expression Comp() :
{ Expression left; String op; Expression right; }
{
	left = ArExpression() op = OpComp() right = ArExpression()
	{ return new BinaryOp(left, op, right); }
}

Expression Expression() :
{ Expression expr; }
{
	expr = LogExpression()
	{ return expr; }
}

/** Comparaison operator production */
String OpComp() :
{ Token t; }
{
	( t = <SMALLER> | t = <BIGGER> | t = <EQUAL> | t = <BIGGER_EQUAL> | t = <SMALLER_EQUAL> )
	{ return t.image; }
}
