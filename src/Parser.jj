PARSER_BEGIN(Parser)

/** Simple brace matcher. */
public class Parser {
	public static void main (String args[]) {
		Parser parser;
		if (args.length == 0) {
			System.out.println("Entrée standard");
			parser = new Parser(System.in);
		} else if (args.length == 1) {
			System.out.println("Analyse du fichier : " + args[0] + " ... ");
			try {
				parser = new Parser(new java.io.FileInputStream(args[0]));
			} catch (java.io.FileNotFoundException e) {
				System.out.println("Le fichier : " + args[0] + " n'est pas trouvé");
				return;
			}
		} else {
			System.out.println("Erreur de lecture");
			return;
		}
		try {
			parser.Input();
			System.out.println("Analyse syntaxique OK");
		} catch (ParseException e) {
			System.out.println("L'analyse syntaxique révèle des erreurs");
		}
	}
}

PARSER_END(Parser)

SKIP : {
    " "
  | "\t"
  | "\n"
  | "\r"
  | "\f"
}

SPECIAL_TOKEN : {
    <SingleLineComment : "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
}

TOKEN : {
      <FUNC            : "func">
	| <PROC			   : "proc">
	| <MAIN            : "main">
	| <RETURN         : "return">
	| <IF             : "if">
	| <ELSE           : "else">
	| <WHILE          : "while">
	| <BEGIN           : "{">
	| <END             : "}">
	| <PARAM_SEPARATOR : ",">
	| <SEMICOLON      : ";">
	| <INT_TYPE        : "int">
	| <BOOL_TYPE       : "bool">
	| <FLOAT_TYPE      : "float">
	| <STR_TYPE        : "str">
	| <INSTRUCTION     : "Instruction"> // temporaire
	| <ASSIGNATION     : "=">
	| <PLUS            : "+">
	| <MINUS           : "-">
	| <MULTIPLY        : "*">
	| <DIVIDE          : "/">
	| <LPAREN          : "(">
	| <RPAREN          : ")">
	| <AND: "&">
	| <OR: "||">
	| <NOT: "!">
	| <SMALLER_EQUAL: "=<">
	| <BIGGER_EQUAL: "=>">
	| <EQUAL: "==">
	| <SMALLER: "<">
	| <BIGGER: ">">
	| <BOOL: "true" | "false">
	| <INTEGER_LITERAL : "0" | ["1"-"9"] (["0"-"9"])* >
	| <FLOAT :
        (["0"-"9"])+ "." (["0"-"9"])* (<EXP>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXP>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXP> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXP>)? ["f","F","d","D"]
    >
	| <#EXP : ["e","E"] (["+","-"])? (["0"-"9"])+ >
	| <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT>)* >
	| <#LETTER :
        [
          "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
          "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
          "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
          "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
        ]
    >
	| <#DIGIT :
        [
          "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
        ]
    >
}

/** Root production. */
void Input() :
{}
{
	Program() <EOF>
}

void Function() :
{}
{
	<FUNC> Type() <IDENTIFIER> <LPAREN> ParamaterList() <RPAREN> <BEGIN> BlocInitialisation() BlocInstructions() <END>
}

void Procedure() :
{}
{
	<PROC> <IDENTIFIER> <LPAREN> ParamaterList() <RPAREN> <BEGIN> BlocInitialisation() BlocInstructions() <END>
}

void Type() :
{}
{
	<INT_TYPE> | <BOOL_TYPE> | <FLOAT_TYPE> | <STR_TYPE>
}

void Instruction() :
{}
{
	/*Toucher pas à ça pitié*/
	LOOKAHEAD(<IDENTIFIER> <ASSIGNATION>) <IDENTIFIER> <ASSIGNATION> Expression() <SEMICOLON>
	| <IDENTIFIER> <LPAREN> InputParametersList() <RPAREN> <SEMICOLON>
	| ReturnStatement() | IfStatement() | WhileStatement()
}

void ParamaterList() :
{}
{
    (Paramater() ( <PARAM_SEPARATOR> Paramater() )*)?
}

void Paramater() :
{}
{
	Type() <IDENTIFIER>
}

void BlocInstructions() :
{}
{
	(Instruction())* 
}

void BlocInitialisation() :
{}
{
	(Initialisation())* 
}

void Initialisation() :
{}
{
	Type() <IDENTIFIER> (<ASSIGNATION> Expression())? <SEMICOLON>
}

void ReturnStatement() :
{}
{
	<RETURN> Expression() <SEMICOLON>
}

void InputParametersList() :
{}
{
	(Expression() ( <PARAM_SEPARATOR> Expression() )* )? 
}

void FunctionCall() :
{}
{
	<IDENTIFIER> <LPAREN> InputParametersList() <RPAREN>
}

void CallFunction() :
{}
{
	<IDENTIFIER> <LPAREN> InputParametersList() <RPAREN> <SEMICOLON>
}

void IfStatement() :
{}
{
	<IF> <LPAREN> LogExpression() <RPAREN> <BEGIN> BlocInstructions() <END> ( <ELSE> <BEGIN> BlocInstructions() <END> )?
}

void WhileStatement() :
{}
{
	<WHILE> <LPAREN> LogExpression() <RPAREN> <BEGIN> BlocInstructions() <END>
}

void ProcFunc () :
{}
{
	Function() | Procedure()	
}

void FunctionProcedureBlock() :
{}
{
	(ProcFunc())*
}

void mainFunction() :
{}
{
	<MAIN> <LPAREN> <RPAREN> <BEGIN> BlocStatement() <END>
}

void BlocStatement() :
{}
{
	(Statement())*
}

void Statement() :
{}
{
	Initialisation() | Instruction()
}

void Program() :
{}
{
	FunctionProcedureBlock() mainFunction()
}

/**
* Opération arithmétique
*/

/** Arithmetic expression production. */
void ArExpression() :
{}
{
	Term() ((<PLUS> | <MINUS>) Term())*
}

/** Term production (multiplication/division). */
void Term() :
{}
{
	Factor() ((<MULTIPLY> | <DIVIDE>) Factor())*
}

/** Factor production (numbers and parenthesized expressions). */
void Factor() :
{}
{
	(<INTEGER_LITERAL> | <FLOAT>) | <LPAREN> ArExpression() <RPAREN> | LOOKAHEAD(<IDENTIFIER> <LPAREN>) FunctionCall() | <IDENTIFIER>
}

/**
* Opération Logique
*/

/** Logical expression production */
void LogExpression() :
{}
{
	LogTerm() (<OR> LogTerm())*
}

/** Logical Term production */
void LogTerm() :
{}
{
	LogElement() (<AND> LogElement())*
}

/** Logical element production */
void LogElement() :
{}
{
	LogValue() | <NOT> LogValue()
}

/** Logical Value production */
void LogValue() :
{}
{
	LOOKAHEAD(ArExpression() OpComp()) Comp() | <BOOL> | "(" LogExpression() ")" | LOOKAHEAD(<IDENTIFIER> <LPAREN>) FunctionCall() | ArExpression()
}

/** Comparaison production */
void Comp() :
{}
{
	ArExpression() OpComp() ArExpression()
}

void Expression() :
{}
{
	LogExpression()
}

/** Comparaison operator production */
void OpComp() :
{}
{
	<SMALLER> | <BIGGER> | <EQUAL> | <BIGGER_EQUAL> | <SMALLER_EQUAL>
}
